<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Audio Stream</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .container {
            text-align: center;
            color: #fff;
        }
        .player {
            background-color: #1a1a1a;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .status {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #888;
        }
        .controls {
            margin-top: 1rem;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="player">
            <h1>ESP32 Audio Stream</h1>
            <div class="controls">
                <button id="startButton">Start Stream</button>
                <button id="stopButton" disabled>Stop Stream</button>
            </div>
            <div class="status" id="status">Disconnected</div>
        </div>
    </div>

    <script>
        let websocket;
        let audioContext;
        let opusDecoder;
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        let isPlaying = false;

        async function startStream() {
            try {
                statusElement.textContent = 'Initializing...';
                startButton.disabled = true;

                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                statusElement.textContent = 'Connecting...';
                connectWebSocket();

            } catch (error) {
                console.error('Error starting stream:', error);
                statusElement.textContent = 'Error: ' + error.message;
                startButton.disabled = false;
            }
        }

        function connectWebSocket() {
            try {
                // Create WebSocket connection
                websocket = new WebSocket(`ws://${window.location.hostname}/ws`);
                websocket.binaryType = 'arraybuffer';

                websocket.onopen = () => {
                    statusElement.textContent = 'Connected - Receiving Audio';
                    stopButton.disabled = false;
                };

                websocket.onclose = () => {
                    statusElement.textContent = 'Disconnected';
                    startButton.disabled = false;
                    stopButton.disabled = true;
                };

                websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusElement.textContent = 'Connection Error';
                    startButton.disabled = false;
                    stopButton.disabled = true;
                };

                websocket.onmessage = async (event) => {
                    if (event.data instanceof ArrayBuffer) {
                        await handleAudioData(event.data);
                    }
                };

            } catch (error) {
                console.error('WebSocket connection error:', error);
                statusElement.textContent = 'Connection Error: ' + error.message;
                startButton.disabled = false;
            }
        }

        let nextPlayTime = 0;
        let audioQueue = [];
        let isProcessingQueue = false;

        async function handleAudioData(pcmData) {
            try {
                // Convert raw PCM data (Int16) to Float32Array for Web Audio API
                const int16Array = new Int16Array(pcmData);
                const float32Data = new Float32Array(int16Array.length);
                
                for (let i = 0; i < int16Array.length; i++) {
                    float32Data[i] = int16Array[i] / 32768.0; // Convert from int16 to float32
                }

                // Add to queue for processing
                audioQueue.push(float32Data);
                
                // Process queue if not already processing
                if (!isProcessingQueue) {
                    processAudioQueue();
                }

            } catch (error) {
                console.error('Error processing audio data:', error);
            }
        }

        function processAudioQueue() {
            if (audioQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            
            const float32Data = audioQueue.shift();
            
            // Create audio buffer from PCM data
            const audioBuffer = audioContext.createBuffer(1, float32Data.length, 96000);
            audioBuffer.copyToChannel(float32Data, 0);

            // Schedule audio playback to prevent overlapping
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            
            // Calculate when to start this chunk
            const now = audioContext.currentTime;
            const startTime = Math.max(now, nextPlayTime);
            
            source.start(startTime);
            
            // Update next play time
            nextPlayTime = startTime + audioBuffer.duration;
            
            // Schedule next buffer processing
            const nextProcessTime = (startTime - now) * 1000 + audioBuffer.duration * 1000;
            setTimeout(() => processAudioQueue(), Math.max(0, nextProcessTime - 5));
        }

        function stopStream() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            statusElement.textContent = 'Disconnected';
            startButton.disabled = false;
            stopButton.disabled = true;
            isPlaying = false;
            audioQueue = [];
            nextPlayTime = 0; // Reset audio timing
        }

        startButton.addEventListener('click', startStream);
        stopButton.addEventListener('click', stopStream);
    </script>
</body>
</html> 